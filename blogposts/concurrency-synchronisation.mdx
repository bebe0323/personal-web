---
title: 'Concurrency and Synchronisation'
date: '2024-02-19'
tags: ['OS', 'UNSW']
courseId: 'COMP3891'
week: 1
publish: true
---

```c
// count is global variable
void increment() {
	int t;
	t = count;
	t = t + 1;
	count = t;
}
void decrement() {
	int t;
	t = count;
	t = t - 1;
	count = t;
}
```

> count is a global variable that is shared between two threads, t is a local variable.
> After calling the increment and decrement functions, the value of count could be one of `{-1, 0, 1}`. The value of count varies based on where the timer changed the processes.


# Critical Region
- Critical region: area of code where the shared resources are accessed.
- Uncoordinated entry to the critical region causes a race condition.

# Accessing Critical Region

<CustomImage src={"/access-critical-regions.png"} alt={"some photo"} />

# Critical Regions Solutions
Conditions required of any solution to the critical region problem.
1. Mutual Exclusion
	- no two processes simultaneously in critical region
2. No assumptions about speed or number of CPUs
3. Progress
	1. the process running outside its critical region doesn't block other processes.
4. Bounded
	1. Processes doesn't wait forever to enter its critical region

### Solution #1
- A lock variable
	- if ```lock === 1```, some other thread is in the critical region and we must wait
	- if ```lock === 0```, no process is in the critical region and the thread can enter


# Concurrency and Synchronisation (Continued)

# Mutual Exclusion by Taking Turns

```C
// thread - i
// enters the critical region if the turn is only 0
while (TRUE) {
	while (turn != 0) /* loop */
	critical_region();
	turn = 1;
	noncritical_region();
}

// thread - ii
while (TRUE) {
	while (turn != 1) /* loop */
	critical_region();
	turn = 0;
	noncritical_region();
}
```

Pros:
- works due to strict alternation
- each process takes its turn
Limitations:
- Busy waiting
- process must wait its turn while the other process is doing something else
- it waits its turn in a while-loop (basically wasting CPU)
	- Doesn't guarantee progress if a process no longer takes a turn
- Poor solution when the processes the critical solution in differing rates:
	- one process requires the critical section in every one hour
	- the other process requires the critical solution in every second

# Mutual Exclusion by Disabling Interrupts
Pros
- simple
Cons
- only available in the kernel / not available in user mode
	- not available to user applications
	- if it is available, the user application would get full control of the computer
- works best for the short critical region codes (doesn't take much time to run)
- does not work on a multiprocessor


# Hardware Support for mutual exclusion
In low level programming, there is no interrupting the instructions.

# Test and Set
- observing the lock is free and lock in one instruction

Pros
- simple
- available at user level (3 or 4 instructions)
	- to any number of processors
	- to implement any number of lock variables
Cons
- busy waits (sits in the loop / burning CPU => termed as a *spin lock*)
	- consumes CPU
	- Starvation is possible (the scheduler chooses which one to choose next) when more than one process is waiting.
	- two processes
		- one enters critical section
		- scheduler changes to second process
		- second one doesn't enter critical section as it is used by the 1st process
		- scheduler changes to first process.
			- first one finish and re-enter the critical section
		- etc, the second process never enters critical section

# Tackling the Busy-Wait problem
- Sleep / Wakeup

# The Producer-Consumer Problem 

# Semaphores

# Semaphore Implementation
```C
typedef struct {
	int count;
	struct process *L; // list of process that is blocked by this semaphore
}
```
Two operations
1. sleep
2. wakeup

